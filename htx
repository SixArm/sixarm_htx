#!/usr/bin/env ruby

# HTX is an HTML processor for formatting our site's web pages.
# HTX is an ad-hoc tool somewhat like Markdown, Textile, or XSLT.
#
# HTX is a work in progress and is not intended yet for public use;
# it is based on our older HTX perl code from 1994-1998.
#
# http://sixarm.com


require 'open4'
require 'pp'
require 'cgi'
require 'fileutils'


class Htx

  attr_reader :docroot
  attr_reader :webroot
  attr_reader :email
  attr_reader :theme
  attr_accessor :hti
  attr_accessor :var

  ###
  #
  # INITIALIZE
  #
  ###

  MYDIR = File.expand_path(File.dirname(__FILE__))+'/'


  # Initialize everything

  def init
    init_lib
    init_shared
    init_themes
    init_var
    init_pwd
    init_hti("header","footer","disqus")
  end


  # HTX adds some helper methods to some of the Ruby core classes.
  
  def init_lib
    puts "init_lib"
    require_dir(MYDIR+"lib/")
  end


  # HTX has a bunch of shared transforms (e.g. tags, cooks)

  def init_shared
    puts "init_shared"
    require_dir(MYDIR+"shared/")
  end


  # HTX provides theme capabilities, such as having custom tags.
  # For example, your website "my.com" can define its own transforms.
  #
  # We use a file naming convention for transforms:
  #  - tag1: tag methods for single tags, e.g. to handle "<foo/>"
  #  - tag2: tag methods for double tags, e.g. to handle "<foo>...</foo>"
  #  - cook: methods that parse files in non-tag ways, e.g. akin to Textile
  #  - helpers: misc, utilities, etc.

  def init_themes
    @themesets||={}
    puts "init_themes"
    Dir.entries(MYDIR+"themes/").grep(/\w/).each{|theme| require_dir(MYDIR+"themes/"+theme+"/") }
  end


  # Each theme must call init with these settings:
  #  - theme = the theme keyword
  #  - :docroot = the system root path to the html files
  #  - :webroot = the web root path to the html pages
  #  - :email = the email address of the administrator
  #
  # Example:
  #   $htx.init_theme(
  #     'foo',
  #     'docroot' => '/var/www/foo/html',
  #     'webroot' => 'http://foo.com',
  #     'email' => 'webmaster@foo.com'
  #   )

  def init_theme(theme,ops={})
    puts "init_theme #{theme}"
    @themesets[theme]=ops
  end


  # HTX methods can pass around semi-global info by using the @var hash.
  # For example, the tag 'foo' could set @var['a']='b' then later on
  # the tag 'bar' could retrieve @var['a']

  def init_var
    @var={}
  end


  # HTX configures itself based on the preset working directory:
  # we look at the current directory path to see if it contains 
  # a theme's name as a directory. If so, we use that theme.
  
  def init_pwd
    puts "init_pwd"
    pwd = Dir.pwd
    @themesets.each_pair{|themesets_key,themesets_val|
      if pwd.index("/#{themesets_key}/")>=0 
        @theme = themesets_key
        @themeset = themesets_val
        @docroot = @themeset['docroot']
        @webroot = @themeset['webroot']
        @email = @themeset['email']
        puts "theme:#{theme}"
      end
      return
    }
    raise "unknown theme for pwd:#{pwd}"
  end


  # HTX preloads some shared files into a shared cache for speed.
  #   - head.hti
  #   - foot.hti
  #   - etc.
  #
  # We access these files like this:
  #   - @hti[:head]
  #   - @hti[:foot]
  #   - etc.

  def init_hti(*keys)
    @hti||={}
    keys.each{|key|
      file_name = @docroot + "/#{key}.hti"
      @hti[key] = File.open(file_name).read || ""
    }
  end


  # HTX has a concept of a "cook" that is smarter than just a tag,
  # and is typically suitable for parsing a simple DSL within a file,
  # or doing something different for a file based on the file path, etc.
  #
  # Each cook must define two methods:
  #  - cook_foo?(text) => returns true if the text should be processed
  #  - cook_foo(text) => processes the text
  
  def init_cooks
  end


  ###
  #
  # TRANSFORM
  #
  ###


  # Call all the built-in transforms
  
  def transform(s)
    s=transform_cook(s)
    s=transform_add_header_and_footer(s)
    s=transform_entire_page(s)
    s=transform_xml_pairs(s)
    s=transform_substitute(s)
  end


  # Call all the cooks
  
  def transform_cook(text)
    @cooks.each{|method_name|
      if send(method_name+'?',text)
        text=send(method_name,text)
      end
    }
    return text
  end
  

  # We prepend the header text & append the footer text
  
  def transform_add_header_and_footer(s)
    @hti['header']+s+@hti['footer']
  end


  # Do all the substitutions, such as replacing text variables
  
  def transform_substitute(s)
    s=transform_substitute_var(s)
    #s=transform_substitute_stars(s)
    #['header','body','title'].each{|tag| s.combine_tag(tag)}
    return s
  end


  def transform_entire_page(s)

    s.gsub!(/\<(include|railapp-gems-and-plugins) *(.*?)\/>/){
      tag=$1
      attr=$2
      send_tag_text("tag1_"+tag,attr)
    }
 
    while result = s.gsub!(/\<(article|citelink|cmd|ed|javascript|lis|list|listy|man|mysql|ruby|sh|sh0|sh1|sh2|talk|skills|see|set|toclist|uri|wikipedia|wikipedias|x)>(.*?)<\/\1>/m){
        tag=$1
        text=$2
        send_tag_text("tag2_",text)
      }
    end
    
    return s
  end


  def transform_xml_pairs(s)
    while result = s.gsub!(/<(#{@theme}:[:\w]+)>(.*?)<\/\1>/m){
        tag=$1
        text=$2
      send_tag_text(tag,text)
      }
    end
    return s
  end


  # Replace variables e.g. "<=foo>" => @var['foo']

  def transform_substitute_var(s)
    s.gsub(/<=(\w+)\>/){ @var[$1] }
  end


  ###
  #
  # IO
  #
  ###


  def read_input(file_path)
    puts 'HTX' + file_path
    file = File.new(file_path)
    text = file.read
    return file, text
  end


  def write_output(file_path,text)
    out = File.open(file_path + 'ml','w')
    out.write(text)
    out.close
  end


  # Return an array of htx input file names that we will process
  
  def input_file_paths
    ((ARGV[0]=='*') ? Dir.entries('.') : ARGV).select{|x| x=~/\.ht$/ and x!=~/^\.\#/}
  end


  # Given a file name, return the corresponding href
  
  def file_path_to_href(file_path)
    @docroot or raise "@docroot missing"
    @webroot or raise "@webroot missing"
    File::expand_path(file_path).sub(@docroot,@webroot).sub(/\.ht$/,'.html').sub(/\/index.html$/,'/')
  end


  # Process an entire file
  
  def process_file_path(file_path)
    file, text = read_input(file_path)
    @var = {
      'file_path' => file_path,
      'canonical' => file_path_to_href(file_path)
    }
    text=transform(text)
    write_output(file_path,text)
  end


  ###
  # 
  # HELPERS
  #
  ###


  # Each theme can add its own cooks, as many as we want.
  # Each of these cooks will be called with the entire page text.
  
  def add_cook(method_name)
    @cooks||=[]
    @cooks << method_name
  end


  # Require all the Ruby files in a given directory

  def require_dir(dir)
    Dir.entries(dir).grep(/\.rb$/).map{|x| dir + x.sub(/\.rb$/,'')}.each{|req|
      require req
    }
  end

  def send_tag_text(tag,text)
    puts "send_tag_text #{tag} ..."
    send(tag_to_method_name(tag),text)
  end

  def tag_to_method_name(tag)
    tag.gsub(/\W/,'_')
  end
  
end


### MAIN

return if !ARGV or ARGV.size<1
$htx = Htx.new
$htx.init
#HTX = $htx
#@@htx = $htx
$htx.input_file_paths.each{|x| $htx.process_file_path(x) }

